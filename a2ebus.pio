//
// An overview of timing.
// Assuming the RP2040 is running at 125MHz, an access cycle looks like
// this:
//
// time (nS)|Cycles| Event
// ---------+------+-----------------------
//       0  |    0 | Phi1 rises
//     300  |   38 | ADDR is valid
//     500  |   63 | Phi1 falls
//     700  |   88 | DATA is valid (from CPU)
//     900  |  112 | DATA is valid (to CPU)
//


.program addrbus 


// All inputs are in terms of absolute GPIO
.define PHI1 11

// In: size 2
// AO_OUT AE_OUT
// Base: 14, count: 2

// Out: size 1
// ADDR_FN
// Base: 7, count: 1

// Side set: size 1 (1 enable bit)
// ADDR_CLK 
// Side base: 5, size count: 1
.side_set 1

// Jump pin: DEVSEL (pin 10)

loop:
    WAIT 1 gpio PHI1        side 0 [15] // wait for phi1 to go high
    SET pins, 1             side 0 [15] // set fn to load register
    SET X, 8                side 0 [5]
    JMP pin skip            side 1      // load reg; skip is DEVSEL is high
    SET pins, 0             side 1      // set fn to shift data
read:
    IN pins, 2              side 0      // read even/odd address bits
    JMP X-- read            side 1      // shift by 1 
    PUSH                    side 0      // send address to processor
skip:
    WAIT 0 gpio PHI1        side 0      // wait for phi1 to go low


% c-sdk {
static inline void init_addrbus(PIO pio, uint sm, uint offset) {
    pio_sm_config conf = addrbus_program_get_default_config(offset);
    sm_config_set_out_pins(&conf, 7, 1);
    sm_config_set_set_pins(&conf, 7, 1);
    sm_config_set_in_pins(&conf, 14);
    sm_config_set_sideset_pins(&conf, 5);
    sm_config_set_jmp_pin(&conf, 10);
    sm_config_set_clkdiv(&conf, 1.0);
    pio_gpio_init(pio, 7);
    pio_gpio_init(pio, 5);
    pio_sm_set_pindirs_with_mask(pio, sm, 1<<7 | 1<< 5, 1<<7 | 1<<5);
    pio_sm_init(pio, sm, offset, &conf);
    pio_sm_set_enabled(pio, sm, true);
}

%}

