//
// An overview of timing.
// Assuming the RP2040 is running at 125MHz, an access cycle looks like
// this:
//
// time (nS)|Cycles| Event
// ---------+------+-----------------------
//       0  |    0 | Phi1 rises
//     300  |   38 | ADDR is valid
//     500  |   63 | Phi1 falls
//     700  |   88 | DATA is valid (from CPU)
//     900  |  112 | DATA is valid (to CPU)
//


.program addrbus 

.define PHI1 11

// In: AO_OUT AE_OUT (Base 14, count 2)
// Out: ADDR_FN (Base 7, count 1)
// Side set: ADDR_CLK (Base 5, count 1)
.side_set 1

// Jump pin: DEVSEL (pin 10)

skip:
    WAIT 1 gpio PHI1        side 0 [15] // wait for phi1 to go high
    SET pins, 1             side 0 [15] // set fn to load register
    SET X, 8                side 0 [5]
    SET pins, 0             side 1      // set fn to shift data
read:
    IN pins, 2              side 0 [1]     // read even/odd address bits
    JMP X-- read            side 1 [1]     // shift by 1 
    WAIT 0 gpio PHI1        side 0 [5]     // wait for phi1 to go low
    JMP pin skip            side 1      // load reg; skip is DEVSEL is high
    PUSH                    side 0      // send address to processor


% c-sdk {
static inline void init_addrbus(PIO pio, uint sm, uint offset) {
    pio_gpio_init(pio,10);
    pio_sm_config conf = addrbus_program_get_default_config(offset);
    sm_config_set_out_pins(&conf, 7, 1);
    sm_config_set_set_pins(&conf, 7, 1);
    sm_config_set_in_pins(&conf, 14);
    sm_config_set_in_shift(&conf, false, false, 0);
    sm_config_set_sideset_pins(&conf, 5);
    sm_config_set_jmp_pin(&conf, 10);
    sm_config_set_clkdiv(&conf, 1.0);
    pio_gpio_init(pio, 7);
    pio_gpio_init(pio, 5);
    pio_sm_set_pindirs_with_mask(pio, sm, 1<<7 | 1<< 5, 1<<7 | 1<<5);
    pio_sm_init(pio, sm, offset, &conf);
    pio_sm_set_enabled(pio, sm, true);
}

%}

